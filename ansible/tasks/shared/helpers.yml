---
# Shared Helper Functions
#
# Usage: include_tasks with 'action' parameter
#
# General Actions:
#   create-volumes      - Create one or more Docker volumes
#   start               - Start container(s) with docker_compose_v2
#   stop                - Stop container(s)
#   restart             - Restart container(s)
#   wait-ready          - Wait for container to respond to curl healthcheck
#   get-volume-path     - Get volume mountpoint, sets _volume_path fact
#   wait-for-file       - Wait for file to exist on disk
#
# *arr Actions:
#   extract-apikey      - Start *arr container, wait, extract API key from config.xml
#   read-apikey         - Read API key from already-running *arr app's config volume
#   patch-auth          - Stop *arr, patch XML auth to External, start, wait
#   add-root-folder     - Check and add root folder if missing
#   add-download-client - Check and add qBittorrent download client if missing
#   add-jellyfin-notify - Check and add Jellyfin notification connection if missing
#   configure-quality   - Run quality profile Python script

# =============================================================================
# CREATE VOLUMES
# Required: volumes (list of volume names)
# =============================================================================
- name: Create Docker volumes
  community.docker.docker_volume:
    name: "{{ item }}"
  loop: "{{ volumes }}"
  when: action == 'create-volumes'

# =============================================================================
# START CONTAINER(S)
# Required: services (list of service names)
# =============================================================================
- name: "Start {{ services | join(', ') }}"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services: "{{ services }}"
    state: present
  when: action == 'start'

# =============================================================================
# STOP CONTAINER(S)
# Required: services (list of service names)
# =============================================================================
- name: "Stop {{ services | join(', ') }}"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services: "{{ services }}"
    state: stopped
  when: action == 'stop'

# =============================================================================
# RESTART CONTAINER(S)
# Required: services (list of service names)
# =============================================================================
- name: "Restart {{ services | join(', ') }}"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services: "{{ services }}"
    state: restarted
  when: action == 'restart'

# =============================================================================
# WAIT FOR CONTAINER READY (curl healthcheck)
# Required: container_name, port
# Optional: health_path (default: ping)
# =============================================================================
- name: "Wait for {{ container_name }} to be ready"
  ansible.builtin.command: "docker exec {{ container_name }} curl -sf http://localhost:{{ port }}/{{ health_path | default('ping') }}"
  register: _wait_result
  until: _wait_result.rc == 0
  retries: 30
  delay: 5
  changed_when: false
  when: action == 'wait-ready'

# =============================================================================
# GET VOLUME MOUNTPOINT
# Required: volume_name
# Sets: _volume_path fact
# =============================================================================
- name: "Get {{ volume_name }} volume mountpoint"
  community.docker.docker_volume_info:
    name: "{{ volume_name }}"
  register: _vol_info
  when: action == 'get-volume-path'

- name: Set volume path fact
  ansible.builtin.set_fact:
    _volume_path: "{{ _vol_info.volume.Mountpoint }}"
  when: action == 'get-volume-path'

# =============================================================================
# WAIT FOR FILE TO EXIST
# Required: file_path
# Optional: timeout (default: 60)
# =============================================================================
- name: "Wait for {{ file_path | basename }} to exist"
  ansible.builtin.wait_for:
    path: "{{ file_path }}"
    timeout: "{{ timeout | default(60) }}"
  become: true
  when: action == 'wait-for-file'

# =============================================================================
# EXTRACT API KEY (start *arr container + read config.xml)
# Required: arr_name, arr_port
# Sets: {{ arr_name }}_api_key, arr_api_key
# =============================================================================
- name: "[{{ arr_name }}] Start container"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services:
      - "{{ arr_name }}"
    state: present
  when: action == 'extract-apikey'

- name: "[{{ arr_name }}] Wait for ready"
  ansible.builtin.command: "docker exec {{ arr_name }} curl -sf http://localhost:{{ arr_port }}/ping"
  register: _arr_ping
  until: _arr_ping.rc == 0
  retries: 30
  delay: 5
  changed_when: false
  when: action == 'extract-apikey'

- name: "[{{ arr_name }}] Get config volume mountpoint"
  community.docker.docker_volume_info:
    name: "{{ arr_name }}_config"
  register: _arr_volume
  when: action in ['extract-apikey', 'read-apikey']

- name: "[{{ arr_name }}] Read config.xml"
  ansible.builtin.slurp:
    src: "{{ _arr_volume.volume.Mountpoint }}/config.xml"
  register: _arr_config_raw
  become: true
  when: action in ['extract-apikey', 'read-apikey']

- name: "[{{ arr_name }}] Set API key facts"
  ansible.builtin.set_fact:
    "{{ arr_name }}_api_key": "{{ (_arr_config_raw.content | b64decode) | regex_search('<ApiKey>(.*)</ApiKey>', '\\1') | first }}"
    arr_api_key: "{{ (_arr_config_raw.content | b64decode) | regex_search('<ApiKey>(.*)</ApiKey>', '\\1') | first }}"
  when: action in ['extract-apikey', 'read-apikey']

- name: "[{{ arr_name }}] API key"
  ansible.builtin.debug:
    msg: "{{ arr_name }} API key: {{ arr_api_key }}"
  when: action in ['extract-apikey', 'read-apikey']

# =============================================================================
# PATCH AUTH (stop → patch XML → start → wait)
# Required: arr_name, arr_port
# =============================================================================
- name: "[{{ arr_name }}] Stop container for auth patch"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services:
      - "{{ arr_name }}"
    state: stopped
  when: action == 'patch-auth'

- name: "[{{ arr_name }}] Get config volume for auth patch"
  community.docker.docker_volume_info:
    name: "{{ arr_name }}_config"
  register: _arr_volume_auth
  when: action == 'patch-auth'

- name: "[{{ arr_name }}] Set auth to External"
  ansible.builtin.replace:
    path: "{{ _arr_volume_auth.volume.Mountpoint }}/config.xml"
    regexp: "{{ item.regexp }}"
    replace: "{{ item.replace }}"
  loop:
    - { regexp: '<AuthenticationMethod>.*</AuthenticationMethod>', replace: '<AuthenticationMethod>External</AuthenticationMethod>' }
    - { regexp: '<AuthenticationRequired>.*</AuthenticationRequired>', replace: '<AuthenticationRequired>DisabledForLocalAddresses</AuthenticationRequired>' }
  become: true
  when: action == 'patch-auth'

- name: "[{{ arr_name }}] Start container after auth patch"
  community.docker.docker_compose_v2:
    project_src: "{{ playbook_dir }}/../compose"
    services:
      - "{{ arr_name }}"
    state: present
  when: action == 'patch-auth'

- name: "[{{ arr_name }}] Wait for ready after auth patch"
  ansible.builtin.command: "docker exec {{ arr_name }} curl -sf http://localhost:{{ arr_port }}/ping"
  register: _arr_ping_auth
  until: _arr_ping_auth.rc == 0
  retries: 30
  delay: 5
  changed_when: false
  when: action == 'patch-auth'

# =============================================================================
# ADD ROOT FOLDER
# Required: arr_name, arr_port, arr_api_path, arr_api_key, arr_root_path
# =============================================================================
- name: "[{{ arr_name }}] Check existing root folders"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf
    -H 'X-Api-Key: {{ arr_api_key }}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/rootfolder
  register: _arr_rootfolders
  changed_when: false
  when: action == 'add-root-folder'

- name: "[{{ arr_name }}] Add root folder {{ arr_root_path }}"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf -X POST
    -H 'Content-Type: application/json'
    -H 'X-Api-Key: {{ arr_api_key }}'
    -d '{"path":"{{ arr_root_path }}"}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/rootfolder
  when: action == 'add-root-folder' and arr_root_path not in _arr_rootfolders.stdout
  changed_when: true

# =============================================================================
# ADD DOWNLOAD CLIENT (qBittorrent via Gluetun)
# Required: arr_name, arr_port, arr_api_path, arr_api_key, arr_qbt_category
# =============================================================================
- name: "[{{ arr_name }}] Check existing download clients"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf
    -H 'X-Api-Key: {{ arr_api_key }}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/downloadclient
  register: _arr_clients
  changed_when: false
  when: action == 'add-download-client'

- name: "[{{ arr_name }}] Add qBittorrent download client"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf -X POST
    -H 'Content-Type: application/json'
    -H 'X-Api-Key: {{ arr_api_key }}'
    -d '{"enable":true,"protocol":"torrent","priority":1,"name":"qBittorrent","implementation":"QBittorrent","configContract":"QBittorrentSettings","fields":[{"name":"host","value":"gluetun"},{"name":"port","value":8080},{"name":"category","value":"{{ arr_qbt_category }}"}]}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/downloadclient
  when: action == 'add-download-client' and "'qBittorrent' not in _arr_clients.stdout"
  changed_when: true

# =============================================================================
# ADD JELLYFIN NOTIFICATION
# Required: arr_name, arr_port, arr_api_path, arr_api_key
# Optional: arr_jellyfin_events (dict of app-specific on* flags)
# =============================================================================
- name: "[{{ arr_name }}] Read Jellyfin API key from .env"
  ansible.builtin.set_fact:
    _jellyfin_api_key: "{{ lookup('ansible.builtin.ini', 'JELLYFIN_API_KEY', type='properties', file=playbook_dir + '/../compose/.env') }}"
  when: action == 'add-jellyfin-notify'

- name: "[{{ arr_name }}] Check existing notifications"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf
    -H 'X-Api-Key: {{ arr_api_key }}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/notification
  register: _arr_notifications
  changed_when: false
  when: action == 'add-jellyfin-notify'

- name: "[{{ arr_name }}] Build Jellyfin notification payload"
  ansible.builtin.set_fact:
    _notify_payload: >-
      {{ _notify_base | combine(arr_jellyfin_events | default({})) }}
  vars:
    _notify_base:
      name: Jellyfin
      implementation: MediaBrowser
      configContract: MediaBrowserSettings
      fields:
        - { name: host, value: jellyfin }
        - { name: port, value: 8096 }
        - { name: apiKey, value: "{{ _jellyfin_api_key }}" }
        - { name: send, value: "false" }
        - { name: updateLibrary, value: true }
      onGrab: false
      onDownload: true
      onUpgrade: true
      onRename: true
      tags: []
  when: action == 'add-jellyfin-notify'

- name: "[{{ arr_name }}] Add Jellyfin notification"
  ansible.builtin.command: >
    docker exec {{ arr_name }} curl -sf -X POST
    -H 'Content-Type: application/json'
    -H 'X-Api-Key: {{ arr_api_key }}'
    -d '{{ _notify_payload | to_json }}'
    http://localhost:{{ arr_port }}{{ arr_api_path }}/notification
  when: action == 'add-jellyfin-notify' and "'Jellyfin' not in _arr_notifications.stdout"
  changed_when: true

# =============================================================================
# CONFIGURE QUALITY PROFILE (Python script)
# Required: arr_name, arr_port, arr_api_key
# =============================================================================
- name: "[{{ arr_name }}] Configure 4K Minimal quality profile"
  ansible.builtin.shell:
    cmd: >
      python3 {{ playbook_dir }}/../ansible/scripts/configure-arr-quality.py
      {{ arr_name }} {{ arr_port }} {{ arr_api_key }}
  register: _arr_quality
  changed_when: _arr_quality.rc == 2
  failed_when: _arr_quality.rc not in [0, 2]
  when: action == 'configure-quality'
